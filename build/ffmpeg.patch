diff --git a/configure b/configure
index ab761c7183..ecc27aeb9b 100755
--- a/configure
+++ b/configure
@@ -1436,14 +1436,8 @@ test_pkg_config(){
     headers="$3"
     funcs="$4"
     shift 4
-    disable $name
-    test_cmd $pkg_config --exists --print-errors $pkg_version || return
-    pkg_cflags=$($pkg_config --cflags $pkg_config_flags $pkg)
-    pkg_libs=$($pkg_config --libs $pkg_config_flags $pkg)
-    check_func_headers "$headers" "$funcs" $pkg_cflags $pkg_libs "$@" &&
-        enable $name &&
-        set_sanitized "${name}_cflags"    $pkg_cflags &&
-        set_sanitized "${name}_extralibs" $pkg_libs
+    enable $name
+    printf "test_pkg_config: %s, %s - %s\n" "$headers" "$funcs" "$@"
 }
 
 check_pkg_config(){
@@ -2298,23 +2292,10 @@ TYPES_LIST="
     struct_v4l2_frmivalenum_discrete
 "
 
-HAVE_LIST="
-    $ARCH_EXT_LIST
-    $(add_suffix _external $ARCH_EXT_LIST)
-    $(add_suffix _inline   $ARCH_EXT_LIST)
-    $ARCH_FEATURES
-    $BUILTIN_LIST
-    $COMPLEX_FUNCS
-    $HAVE_LIST_CMDLINE
-    $HAVE_LIST_PUB
-    $HEADERS_LIST
-    $INTRINSICS_LIST
-    $MATH_FUNCS
-    $SYSTEM_FEATURES
+IGNORE_LIST="
     $SYSTEM_FUNCS
+    $SYSTEM_FEATURES
     $SYSTEM_LIBRARIES
-    $THREADS_LIST
-    $TOOLCHAIN_FEATURES
     $TYPES_LIST
     makeinfo
     makeinfo_html
@@ -2328,6 +2309,25 @@ HAVE_LIST="
     pod2man
     texi2html
 "
+for opt in $IGNORE_LIST; do
+    disable $opt
+done
+
+HAVE_LIST="
+    $ARCH_EXT_LIST
+    $(add_suffix _external $ARCH_EXT_LIST)
+    $(add_suffix _inline   $ARCH_EXT_LIST)
+    $ARCH_FEATURES
+    $BUILTIN_LIST
+    $COMPLEX_FUNCS
+    $HAVE_LIST_CMDLINE
+    $HAVE_LIST_PUB
+    $HEADERS_LIST
+    $INTRINSICS_LIST
+    $MATH_FUNCS
+    $THREADS_LIST
+    $TOOLCHAIN_FEATURES
+"
 
 # options emitted with CONFIG_ prefix but not available on the command line
 CONFIG_EXTRA="
@@ -4299,13 +4299,6 @@ enabled cross_compile || host_cc_default=$cc
 set_default host_cc
 
 pkg_config_fail_message=""
-if ! $pkg_config --version >/dev/null 2>&1; then
-    warn "$pkg_config not found, library detection may fail."
-    pkg_config=false
-elif is_in -static $cc $LDFLAGS && ! is_in --static $pkg_config $pkg_config_flags; then
-    pkg_config_fail_message="
-Note: When building a static binary, add --pkg-config-flags=\"--static\"."
-fi
 
 if test $doxygen != $doxygen_default && \
   ! $doxygen --version >/dev/null 2>&1; then
@@ -6475,28 +6468,14 @@ if enabled decklink; then
     esac
 fi
 
-enabled securetransport &&
-    check_func SecIdentityCreate "-Wl,-framework,CoreFoundation -Wl,-framework,Security" &&
-    check_lib securetransport "Security/SecureTransport.h Security/Security.h" "SSLCreateContext" "-Wl,-framework,CoreFoundation -Wl,-framework,Security" ||
-        disable securetransport
-
-enabled securetransport &&
-    check_func SecItemImport "-Wl,-framework,CoreFoundation -Wl,-framework,Security"
-
-enabled schannel &&
-    check_func_headers "windows.h security.h" InitializeSecurityContext -DSECURITY_WIN32 -lsecur32 &&
-    test_cpp_condition winerror.h "defined(SEC_I_CONTEXT_EXPIRED)" &&
-    schannel_extralibs="-lsecur32" ||
-        disable schannel
-
-makeinfo --version > /dev/null 2>&1 && enable makeinfo  || disable makeinfo
-enabled makeinfo \
-    && [ 0$(makeinfo --version | grep "texinfo" | sed 's/.*texinfo[^0-9]*\([0-9]*\)\..*/\1/') -ge 5 ] \
-    && enable makeinfo_html || disable makeinfo_html
-disabled makeinfo_html && texi2html --help 2> /dev/null | grep -q 'init-file' && enable texi2html || disable texi2html
-perl -v            > /dev/null 2>&1 && enable perl      || disable perl
-pod2man --help     > /dev/null 2>&1 && enable pod2man   || disable pod2man
-rsync --help 2> /dev/null | grep -q 'contimeout' && enable rsync_contimeout || disable rsync_contimeout
+disable securetransport
+disable schannel
+
+disable makeinfo
+disable texi2html
+disable perl
+disable pod2man
+disable rsync_contimeout
 
 # check V4L2 codecs available in the API
 if enabled v4l2_m2m; then
@@ -6994,17 +6973,8 @@ check_deps $CONFIG_LIST       \
 enabled threads && ! enabled pthreads && ! enabled atomics_native && die "non pthread threading without atomics not supported, try adding --enable-pthreads or --cpu=i486 or higher if you are on x86"
 enabled avresample && warn "Building with deprecated library libavresample"
 
-case $target_os in
-haiku)
-    disable memalign
-    disable posix_memalign
-    ;;
-*-dos|freedos|opendos)
-    if test_cpp_condition sys/version.h "defined(__DJGPP__) && __DJGPP__ == 2 && __DJGPP_MINOR__ == 5"; then
-        disable memalign
-    fi
-    ;;
-esac
+disable memalign
+disable posix_memalign
 
 flatten_extralibs(){
     nested_entries=
@@ -7470,7 +7440,7 @@ cat > $TMPH <<EOF
 /* Automatically generated by configure - do not modify! */
 #ifndef FFMPEG_CONFIG_H
 #define FFMPEG_CONFIG_H
-#define FFMPEG_CONFIGURATION "$(c_escape $FFMPEG_CONFIGURATION)"
+#define FFMPEG_CONFIGURATION ""
 #define FFMPEG_LICENSE "$(c_escape $license)"
 #define CONFIG_THIS_YEAR 2020
 #define FFMPEG_DATADIR "$(eval c_escape $datadir)"
@@ -7498,7 +7468,8 @@ if enabled x86asm; then
 EOF
 fi
 
-enabled getenv || echo "#define getenv(x) NULL" >> $TMPH
+echo "#include <stdlib.h>" >> $TMPH
+echo "#define getenv(x) NULL" >> $TMPH
 
 
 mkdir -p doc
@@ -7508,6 +7479,7 @@ echo "@c auto-generated by configure - do not modify! " > doc/config.texi
 
 print_config ARCH_   "$config_files" $ARCH_LIST
 print_config HAVE_   "$config_files" $HAVE_LIST
+print_config HAVE_   "$config_files" $IGNORE_LIST
 print_config CONFIG_ "$config_files" $CONFIG_LIST       \
                                      $CONFIG_EXTRA      \
                                      $ALL_COMPONENTS    \
diff --git a/libavcodec/encode.c b/libavcodec/encode.c
index 9ed2cf0f59..5b6965a2e3 100644
--- a/libavcodec/encode.c
+++ b/libavcodec/encode.c
@@ -289,6 +289,7 @@ int attribute_align_arg avcodec_encode_video2(AVCodecContext *avctx,
         return 0;
     }
 
+#if !defined(__EMSCRIPTEN__)
     if (av_image_check_size2(avctx->width, avctx->height, avctx->max_pixels, AV_PIX_FMT_NONE, 0, avctx))
         return AVERROR(EINVAL);
 
@@ -298,6 +299,7 @@ int attribute_align_arg avcodec_encode_video2(AVCodecContext *avctx,
         av_log(avctx, AV_LOG_WARNING, "AVFrame.width or height is not set\n");
 
     av_assert0(avctx->codec->encode2);
+#endif
 
     ret = avctx->codec->encode2(avctx, avpkt, frame, got_packet_ptr);
     av_assert0(ret <= 0);
diff --git a/libavcodec/h264_slice.c b/libavcodec/h264_slice.c
index e24d41ca50..c34d7885f9 100644
--- a/libavcodec/h264_slice.c
+++ b/libavcodec/h264_slice.c
@@ -48,6 +48,11 @@
 #include "rectangle.h"
 #include "thread.h"
 
+#define NEED_FILTER 0
+#if !NEED_FILTER
+# define loop_filter(...) ((void)0)
+#endif
+
 static const uint8_t field_scan[16+1] = {
     0 + 0 * 4, 0 + 1 * 4, 1 + 0 * 4, 0 + 2 * 4,
     0 + 3 * 4, 1 + 1 * 4, 1 + 2 * 4, 1 + 3 * 4,
@@ -1980,6 +1985,7 @@ static int h264_slice_init(H264Context *h, H264SliceContext *sl,
     if (!h->setup_finished)
         ff_h264_direct_ref_list_init(h, sl);
 
+#if NEED_FILTER
     if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||
         (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&
          h->nal_unit_type != H264_NAL_IDR_SLICE) ||
@@ -2000,6 +2006,9 @@ static int h264_slice_init(H264Context *h, H264SliceContext *sl,
             h->postpone_filter = 1;
         }
     }
+#else
+    sl->deblocking_filter = 0;
+#endif
     sl->qp_thresh = 15 -
                    FFMIN(sl->slice_alpha_c0_offset, sl->slice_beta_offset) -
                    FFMAX3(0,
@@ -2051,6 +2060,7 @@ static int h264_slice_init(H264Context *h, H264SliceContext *sl,
                              (sl->ref_list[j][i].reference & 3);
     }
 
+#if 0
     if (h->avctx->debug & FF_DEBUG_PICT_INFO) {
         av_log(h->avctx, AV_LOG_DEBUG,
                "slice:%d %s mb:%d %c%s%s frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n",
@@ -2071,6 +2081,7 @@ static int h264_slice_init(H264Context *h, H264SliceContext *sl,
                sl->pwt.use_weight == 1 && sl->pwt.use_weight_chroma ? "c" : "",
                sl->slice_type == AV_PICTURE_TYPE_B ? (sl->direct_spatial_mv_pred ? "SPAT" : "TEMP") : "");
     }
+#endif
 
     return 0;
 }
@@ -2444,6 +2455,7 @@ static int fill_filter_caches(const H264Context *h, H264SliceContext *sl, int mb
     return 0;
 }
 
+#if NEED_FILTER
 static void loop_filter(const H264Context *h, H264SliceContext *sl, int start_x, int end_x)
 {
     uint8_t *dest_y, *dest_cb, *dest_cr;
@@ -2513,6 +2525,7 @@ static void loop_filter(const H264Context *h, H264SliceContext *sl, int start_x,
     sl->chroma_qp[0] = get_chroma_qp(h->ps.pps, 0, sl->qscale);
     sl->chroma_qp[1] = get_chroma_qp(h->ps.pps, 1, sl->qscale);
 }
+#endif /* NEED_FILTER */
 
 static void predict_field_decoding_flag(const H264Context *h, H264SliceContext *sl)
 {
@@ -2591,7 +2604,9 @@ static int decode_slice(struct AVCodecContext *avctx, void *arg)
 
     av_assert0(h->block_offset[15] == (4 * ((scan8[15] - scan8[0]) & 7) << h->pixel_shift) + 4 * sl->linesize * ((scan8[15] - scan8[0]) >> 3));
 
+#if NEED_FILTER
     if (h->postpone_filter)
+#endif
         sl->deblocking_filter = 0;
 
     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||
@@ -2845,6 +2860,7 @@ int ff_h264_execute_decode_slices(H264Context *h)
                 h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;
         }
 
+#if NEED_FILTER
         if (h->postpone_filter) {
             h->postpone_filter = 0;
 
@@ -2862,6 +2878,7 @@ int ff_h264_execute_decode_slices(H264Context *h)
                 }
             }
         }
+#endif
     }
 
 finish:
diff --git a/libavcodec/libvpxenc.c b/libavcodec/libvpxenc.c
index 60a858853d..9c34ffb448 100644
--- a/libavcodec/libvpxenc.c
+++ b/libavcodec/libvpxenc.c
@@ -41,6 +41,11 @@
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
 
+#define NEED_SSE 0
+#define NEED_ALPHA 0
+#define NEED_STATS 0
+#define AVPKT_PASSTH 1
+
 /**
  * Portion of struct vpx_codec_cx_pkt from vpx_encoder.h.
  * One encoded frame returned from the library.
@@ -292,9 +297,13 @@ static void coded_frame_add(void *list, struct FrameListData *cx_frame)
 
 static av_cold void free_coded_frame(struct FrameListData *cx_frame)
 {
+#if !AVPKT_PASSTH
     av_freep(&cx_frame->buf);
+#endif
+#if NEED_ALPHA
     if (cx_frame->buf_alpha)
         av_freep(&cx_frame->buf_alpha);
+#endif
     av_freep(&cx_frame);
 }
 
@@ -357,6 +366,7 @@ static av_cold int vpx_free(AVCodecContext *avctx)
 {
     VPxContext *ctx = avctx->priv_data;
 
+#if CONFIG_LIBVPX_VP9_ENCODER
 #if VPX_ENCODER_ABI_VERSION >= 12
     if (avctx->codec_id == AV_CODEC_ID_VP9 && ctx->level >= 0 &&
         !(avctx->flags & AV_CODEC_FLAG_PASS1)) {
@@ -365,17 +375,21 @@ static av_cold int vpx_free(AVCodecContext *avctx)
             av_log(avctx, AV_LOG_INFO, "Encoded level %.1f\n", level_out * 0.1);
     }
 #endif
-
+#endif
     av_freep(&ctx->ts_layer_flags);
 
     vpx_codec_destroy(&ctx->encoder);
+#if NEED_ALPHA
     if (ctx->is_alpha) {
         vpx_codec_destroy(&ctx->encoder_alpha);
         av_freep(&ctx->rawimg_alpha.planes[VPX_PLANE_U]);
         av_freep(&ctx->rawimg_alpha.planes[VPX_PLANE_V]);
     }
+#endif
+#if NEED_STATS
     av_freep(&ctx->twopass_stats.buf);
     av_freep(&avctx->stats_out);
+#endif
     free_frame_list(ctx->coded_frame_list);
     return 0;
 }
@@ -745,8 +759,10 @@ static av_cold int vpx_init(AVCodecContext *avctx,
     av_log(avctx, AV_LOG_INFO, "%s\n", vpx_codec_version_str());
     av_log(avctx, AV_LOG_VERBOSE, "%s\n", vpx_codec_build_config());
 
+#if NEED_ALPHA
     if (avctx->pix_fmt == AV_PIX_FMT_YUVA420P)
         ctx->is_alpha = 1;
+#endif
 
     if ((res = vpx_codec_enc_config_default(iface, &enccfg, 0)) != VPX_CODEC_OK) {
         av_log(avctx, AV_LOG_ERROR, "Failed to get config: %s\n",
@@ -874,6 +890,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
     if (enccfg.g_pass == VPX_RC_FIRST_PASS)
         enccfg.g_lag_in_frames = 0;
+#if NEED_STATS
     else if (enccfg.g_pass == VPX_RC_LAST_PASS) {
         int decode_size, ret;
 
@@ -901,6 +918,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
         ctx->twopass_stats.sz      = decode_size;
         enccfg.rc_twopass_stats_in = ctx->twopass_stats;
     }
+#endif
 
     /* 0-3: For non-zero values the encoder increasingly optimizes for reduced
        complexity playback on low powered devices at the expense of encode
@@ -939,6 +957,8 @@ FF_ENABLE_DEPRECATION_WARNINGS
 #endif
     }
 #endif
+
+#if NEED_ALPHA
     if (ctx->is_alpha) {
         enccfg_alpha = enccfg;
         res = vpx_codec_enc_init(&ctx->encoder_alpha, iface, &enccfg_alpha, flags);
@@ -947,6 +967,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
             return AVERROR(EINVAL);
         }
     }
+#endif
 
     //codec control failures are currently treated only as warnings
     av_log(avctx, AV_LOG_DEBUG, "vpx_codec_control\n");
@@ -965,10 +986,12 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (ctx->tune >= 0)
         codecctl_int(avctx, VP8E_SET_TUNING,           ctx->tune);
 
+#if NEED_ALPHA
     if (ctx->auto_alt_ref && ctx->is_alpha && avctx->codec_id == AV_CODEC_ID_VP8) {
         av_log(avctx, AV_LOG_ERROR, "Transparency encoding with auto_alt_ref does not work\n");
         return AVERROR(EINVAL);
     }
+#endif
 
     if (ctx->sharpness >= 0)
         codecctl_int(avctx, VP8E_SET_SHARPNESS, ctx->sharpness);
@@ -1059,9 +1082,14 @@ static inline void cx_pktcpy(struct FrameListData *dst,
     dst->sz       = src->data.frame.sz;
     dst->buf      = src->data.frame.buf;
     dst->have_sse = 0;
+#if AVPKT_PASSTH
+    ((struct vpx_codec_cx_pkt *)src)->data.frame.sz = 0;
+    ((struct vpx_codec_cx_pkt *)src)->data.frame.buf = NULL;
+#endif
     /* For alt-ref frame, don't store PSNR or increment frame_number */
     if (!(dst->flags & VPX_FRAME_IS_INVISIBLE)) {
         dst->frame_number = ++ctx->frame_number;
+#if NEED_SSE
         dst->have_sse = ctx->have_sse;
         if (ctx->have_sse) {
             /* associate last-seen SSE to the frame. */
@@ -1071,9 +1099,11 @@ static inline void cx_pktcpy(struct FrameListData *dst,
             memcpy(dst->sse, ctx->sse, sizeof(dst->sse));
             ctx->have_sse = 0;
         }
+#endif
     } else {
         dst->frame_number = -1;   /* sanity marker */
     }
+#if NEED_ALPHA
     if (src_alpha) {
         dst->buf_alpha = src_alpha->data.frame.buf;
         dst->sz_alpha = src_alpha->data.frame.sz;
@@ -1081,8 +1111,15 @@ static inline void cx_pktcpy(struct FrameListData *dst,
         dst->buf_alpha = NULL;
         dst->sz_alpha = 0;
     }
+#endif
 }
 
+#if AVPKT_PASSTH
+// With this hack we are not allocating nor copying new buffers, instead we do passthrough a pointer
+// to the buffer received from libvpx's vp8e_encode, thus we don't need to free it up ourselves.
+static void av_buffer_dummy_free(void *opaque, uint8_t *data) {}
+#endif
+
 /**
  * Store coded frame information in format suitable for return from encode2().
  *
@@ -1093,11 +1130,20 @@ static inline void cx_pktcpy(struct FrameListData *dst,
 static int storeframe(AVCodecContext *avctx, struct FrameListData *cx_frame,
                       AVPacket *pkt)
 {
+#if AVPKT_PASSTH
+    int pict_type;
+    pkt->buf = av_buffer_create(cx_frame->buf, cx_frame->sz, av_buffer_dummy_free, NULL, 0);
+    if (!pkt->buf) return AVERROR(ENOMEM);
+    pkt->size = pkt->buf->size;
+    pkt->data = pkt->buf->data;
+    cx_frame->buf = NULL;
+    cx_frame->sz = 0;
+#else
     int ret = ff_alloc_packet2(avctx, pkt, cx_frame->sz, 0);
-    uint8_t *side_data;
     if (ret >= 0) {
         int pict_type;
         memcpy(pkt->data, cx_frame->buf, pkt->size);
+#endif
         pkt->pts = pkt->dts = cx_frame->pts;
 #if FF_API_CODED_FRAME
 FF_DISABLE_DEPRECATION_WARNINGS
@@ -1123,9 +1169,12 @@ FF_ENABLE_DEPRECATION_WARNINGS
 #endif
         }
 
+#if NEED_STATS
         ff_side_data_set_encoder_stats(pkt, 0, cx_frame->sse + 1,
                                        cx_frame->have_sse ? 3 : 0, pict_type);
+#endif
 
+#if NEED_SSE
         if (cx_frame->have_sse) {
             int i;
             /* Beware of the Y/U/V/all order! */
@@ -1142,8 +1191,10 @@ FF_ENABLE_DEPRECATION_WARNINGS
             }
             cx_frame->have_sse = 0;
         }
+#endif /* NEED_SSE */
+#if NEED_ALPHA
         if (cx_frame->sz_alpha > 0) {
-            side_data = av_packet_new_side_data(pkt,
+            uint8_t *side_data = av_packet_new_side_data(pkt,
                                                 AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
                                                 cx_frame->sz_alpha + 8);
             if(!side_data) {
@@ -1154,9 +1205,12 @@ FF_ENABLE_DEPRECATION_WARNINGS
             AV_WB64(side_data, 1);
             memcpy(side_data + 8, cx_frame->buf_alpha, cx_frame->sz_alpha);
         }
+#endif /* NEED_ALPHA */
+#if !AVPKT_PASSTH
     } else {
         return ret;
     }
+#endif
     return pkt->size;
 }
 
@@ -1168,7 +1222,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
  * @return AVERROR(EINVAL) on output size error
  * @return AVERROR(ENOMEM) on coded frame queue data allocation error
  */
-static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
+static inline int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
 {
     VPxContext *ctx = avctx->priv_data;
     const struct vpx_codec_cx_pkt *pkt;
@@ -1189,11 +1243,20 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
 
     /* consume all available output from the encoder before returning. buffers
        are only good through the next vpx_codec call */
+#if NEED_ALPHA
     while ((pkt = vpx_codec_get_cx_data(&ctx->encoder, &iter)) &&
            (!ctx->is_alpha ||
             (pkt_alpha = vpx_codec_get_cx_data(&ctx->encoder_alpha, &iter_alpha)))) {
+#else
+    while ((pkt = vpx_codec_get_cx_data(&ctx->encoder, &iter))) {
+#endif
+#if (NEED_SSE || NEED_STATS)
         switch (pkt->kind) {
         case VPX_CODEC_CX_FRAME_PKT:
+#else
+// XXX: Yes, this may get optimized by the compiler anyway..
+        if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
+#endif
             if (!size) {
                 struct FrameListData cx_frame;
 
@@ -1213,6 +1276,7 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
                     return AVERROR(ENOMEM);
                 }
                 cx_pktcpy(cx_frame, pkt, pkt_alpha, ctx);
+#if !AVPKT_PASSTH
                 cx_frame->buf = av_malloc(cx_frame->sz);
 
                 if (!cx_frame->buf) {
@@ -1223,6 +1287,8 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
                     return AVERROR(ENOMEM);
                 }
                 memcpy(cx_frame->buf, pkt->data.frame.buf, pkt->data.frame.sz);
+#endif
+#if NEED_ALPHA
                 if (ctx->is_alpha) {
                     cx_frame->buf_alpha = av_malloc(cx_frame->sz_alpha);
                     if (!cx_frame->buf_alpha) {
@@ -1234,10 +1300,13 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
                     }
                     memcpy(cx_frame->buf_alpha, pkt_alpha->data.frame.buf, pkt_alpha->data.frame.sz);
                 }
+#endif
                 coded_frame_add(&ctx->coded_frame_list, cx_frame);
             }
+#if (NEED_SSE || NEED_STATS)
             break;
         case VPX_CODEC_STATS_PKT: {
+#if NEED_STATS
             struct vpx_fixed_buf *stats = &ctx->twopass_stats;
             int err;
             if ((err = av_reallocp(&stats->buf,
@@ -1250,19 +1319,23 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
             memcpy((uint8_t*)stats->buf + stats->sz,
                    pkt->data.twopass_stats.buf, pkt->data.twopass_stats.sz);
             stats->sz += pkt->data.twopass_stats.sz;
+#endif
             break;
         }
         case VPX_CODEC_PSNR_PKT:
+#if NEED_SSE
             av_assert0(!ctx->have_sse);
             ctx->sse[0] = pkt->data.psnr.sse[0];
             ctx->sse[1] = pkt->data.psnr.sse[1];
             ctx->sse[2] = pkt->data.psnr.sse[2];
             ctx->sse[3] = pkt->data.psnr.sse[3];
             ctx->have_sse = 1;
+#endif
             break;
         case VPX_CODEC_CUSTOM_PKT:
             //ignore unsupported/unrecognized packet types
             break;
+#endif /* NEED_SSE || NEED_STATS */
         }
     }
 
@@ -1498,6 +1571,7 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
         rawimg->stride[VPX_PLANE_Y] = frame->linesize[0];
         rawimg->stride[VPX_PLANE_U] = frame->linesize[1];
         rawimg->stride[VPX_PLANE_V] = frame->linesize[2];
+#if NEED_ALPHA
         if (ctx->is_alpha) {
             rawimg_alpha = &ctx->rawimg_alpha;
             res = realloc_alpha_uv(avctx, frame->width, frame->height);
@@ -1506,6 +1580,7 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
             rawimg_alpha->planes[VPX_PLANE_Y] = frame->data[3];
             rawimg_alpha->stride[VPX_PLANE_Y] = frame->linesize[3];
         }
+#endif
         timestamp                   = frame->pts;
 #if VPX_IMAGE_ABI_VERSION >= 4
         switch (frame->color_range) {
@@ -1589,6 +1664,7 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
         return AVERROR_INVALIDDATA;
     }
 
+#if NEED_ALPHA
     if (ctx->is_alpha) {
         res = vpx_codec_encode(&ctx->encoder_alpha, rawimg_alpha, timestamp,
                                avctx->ticks_per_frame, flags, ctx->deadline);
@@ -1597,10 +1673,11 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
             return AVERROR_INVALIDDATA;
         }
     }
-
+#endif
     coded_size = queue_frames(avctx, pkt);
 
     if (!frame && avctx->flags & AV_CODEC_FLAG_PASS1) {
+#if NEED_STATS
         unsigned int b64_size = AV_BASE64_SIZE(ctx->twopass_stats.sz);
 
         avctx->stats_out = av_malloc(b64_size);
@@ -1611,6 +1688,7 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
         }
         av_base64_encode(avctx->stats_out, b64_size, ctx->twopass_stats.buf,
                          ctx->twopass_stats.sz);
+#endif /* NEED_STATS */
     } else if (enccfg->ts_number_layers > 1 && ctx->ts_layer_flags) {
         ctx->current_temporal_idx = (ctx->current_temporal_idx + 1) % enccfg->ts_periodicity;
     }
diff --git a/libavutil/avassert.h b/libavutil/avassert.h
index 9abeadea4a..919707a909 100644
--- a/libavutil/avassert.h
+++ b/libavutil/avassert.h
@@ -42,6 +42,10 @@
     }                                                                   \
 } while (0)
 
+#if defined(__EMSCRIPTEN__)
+# undef av_assert0
+# define av_assert0(cond) ((void)0)
+#endif
 
 /**
  * assert() equivalent, that does not lie in speed critical code.
diff --git a/libavutil/bprint.c b/libavutil/bprint.c
index 2f059c5ba6..989efe24ce 100644
--- a/libavutil/bprint.c
+++ b/libavutil/bprint.c
@@ -175,6 +175,7 @@ void av_bprint_append_data(AVBPrint *buf, const char *data, unsigned size)
 
 void av_bprint_strftime(AVBPrint *buf, const char *fmt, const struct tm *tm)
 {
+#if !defined(__EMSCRIPTEN__)
     unsigned room;
     size_t l;
 
@@ -213,6 +214,7 @@ void av_bprint_strftime(AVBPrint *buf, const char *fmt, const struct tm *tm)
         }
     }
     av_bprint_grow(buf, l);
+#endif
 }
 
 void av_bprint_get_buffer(AVBPrint *buf, unsigned size,
diff --git a/libavutil/cpu.c b/libavutil/cpu.c
index 6548cc3042..4b487a92f2 100644
--- a/libavutil/cpu.c
+++ b/libavutil/cpu.c
@@ -279,6 +279,8 @@ int av_cpu_count(void)
 
     if (!sched_getaffinity(0, sizeof(cpuset), &cpuset))
         nb_cpus = CPU_COUNT(&cpuset);
+#elif defined(__EMSCRIPTEN__)
+    nb_cpus = 8;
 #elif HAVE_GETPROCESSAFFINITYMASK
     DWORD_PTR proc_aff, sys_aff;
     if (GetProcessAffinityMask(GetCurrentProcess(), &proc_aff, &sys_aff))
diff --git a/libavutil/dict.c b/libavutil/dict.c
index 0ea71386e5..733a2807ff 100644
--- a/libavutil/dict.c
+++ b/libavutil/dict.c
@@ -257,6 +257,7 @@ int av_dict_get_string(const AVDictionary *m, char **buffer,
 
 int avpriv_dict_set_timestamp(AVDictionary **dict, const char *key, int64_t timestamp)
 {
+#if !defined(__EMSCRIPTEN__)
     time_t seconds = timestamp / 1000000;
     struct tm *ptm, tmbuf;
     ptm = gmtime_r(&seconds, &tmbuf);
@@ -269,4 +270,7 @@ int avpriv_dict_set_timestamp(AVDictionary **dict, const char *key, int64_t time
     } else {
         return AVERROR_EXTERNAL;
     }
+#else
+    return AVERROR_EXTERNAL;
+#endif
 }
diff --git a/libavutil/log.c b/libavutil/log.c
index 8d4945249e..a1eb104ae8 100644
--- a/libavutil/log.c
+++ b/libavutil/log.c
@@ -404,6 +404,7 @@ end:
 static void (*av_log_callback)(void*, int, const char*, va_list) =
     av_log_default_callback;
 
+#if !defined(NO_AVLOG)
 void av_log(void* avcl, int level, const char *fmt, ...)
 {
     va_list vl;
@@ -431,6 +432,7 @@ void av_vlog(void* avcl, int level, const char *fmt, va_list vl)
     if (log_callback)
         log_callback(avcl, level, fmt, vl);
 }
+#endif // !defined(NO_AVLOG)
 
 int av_log_get_level(void)
 {
diff --git a/libavutil/log.h b/libavutil/log.h
index 9c14188a9c..996bb310dd 100644
--- a/libavutil/log.h
+++ b/libavutil/log.h
@@ -380,4 +380,9 @@ int av_log_get_flags(void);
  * @}
  */
 
+#if defined(NO_AVLOG)
+# define av_log(...) ((void)0)
+# define av_vlog(...) ((void)0)
+#endif
+
 #endif /* AVUTIL_LOG_H */
diff --git a/libavutil/parseutils.c b/libavutil/parseutils.c
index 167e822648..bca3152502 100644
--- a/libavutil/parseutils.c
+++ b/libavutil/parseutils.c
@@ -488,6 +488,7 @@ static int date_get_month(const char **pp) {
 
 char *av_small_strptime(const char *p, const char *fmt, struct tm *dt)
 {
+#if !defined(__EMSCRIPTEN__)
     int c, val;
 
     while((c = *fmt++)) {
@@ -561,6 +562,7 @@ char *av_small_strptime(const char *p, const char *fmt, struct tm *dt)
             return NULL;
         }
     }
+#endif
 
     return (char*)p;
 }
@@ -586,6 +588,7 @@ time_t av_timegm(struct tm *tm)
 
 int av_parse_time(int64_t *timeval, const char *timestr, int duration)
 {
+#if !defined(__EMSCRIPTEN__)
     const char *p, *q;
     int64_t t, now64;
     time_t now;
@@ -744,6 +747,9 @@ int av_parse_time(int64_t *timeval, const char *timestr, int duration)
     t += microseconds;
     *timeval = negative ? -t : t;
     return 0;
+#else
+    return AVERROR(EINVAL);
+#endif
 }
 
 int av_find_info_tag(char *arg, int arg_size, const char *tag1, const char *info)
diff --git a/libavutil/random_seed.c b/libavutil/random_seed.c
index 70dc509d2f..ffaaf6ded6 100644
--- a/libavutil/random_seed.c
+++ b/libavutil/random_seed.c
@@ -133,6 +133,10 @@ uint32_t av_get_random_seed(void)
     }
 #endif
 
+#if defined(__EMSCRIPTEN__)
+    // https://imgs.xkcd.com/comics/random_number.png
+    return 4;
+#endif
 #if HAVE_ARC4RANDOM
     return arc4random();
 #endif
diff --git a/libavutil/time.c b/libavutil/time.c
index afa6658aa6..26e4c82353 100644
--- a/libavutil/time.c
+++ b/libavutil/time.c
@@ -36,6 +36,21 @@
 #include "time.h"
 #include "error.h"
 
+#if defined(__EMSCRIPTEN__)
+# undef HAVE_GETTIMEOFDAY
+# undef HAVE_GETSYSTEMTIMEASFILETIME
+# undef HAVE_CLOCK_GETTIME
+# undef HAVE_NANOSLEEP
+# undef HAVE_USLEEP
+# undef HAVE_SLEEP
+# define HAVE_GETTIMEOFDAY 0
+# define HAVE_GETSYSTEMTIMEASFILETIME 0
+# define HAVE_CLOCK_GETTIME 0
+# define HAVE_NANOSLEEP 0
+# define HAVE_USLEEP 0
+# define HAVE_SLEEP 0
+#endif
+
 int64_t av_gettime(void)
 {
 #if HAVE_GETTIMEOFDAY
diff --git a/libavutil/tx.c b/libavutil/tx.c
index 3b0568a5e1..ba3b6fc98b 100644
--- a/libavutil/tx.c
+++ b/libavutil/tx.c
@@ -38,6 +38,7 @@ static av_always_inline int mulinv(int n, int m)
         if (((n * x) % m) == 1)
             return x;
     av_assert0(0); /* Never reached */
+    return 1;
 }
 
 /* Guaranteed to work for any n, m where gcd(n, m) == 1 */
diff --git a/libavutil/utils.c b/libavutil/utils.c
index c1cd452eee..9ca17d0b25 100644
--- a/libavutil/utils.c
+++ b/libavutil/utils.c
@@ -102,7 +102,7 @@ char av_get_picture_type_char(enum AVPictureType pict_type)
 unsigned av_int_list_length_for_size(unsigned elsize,
                                      const void *list, uint64_t term)
 {
-    unsigned i;
+    unsigned i = 0;
 
     if (!list)
         return 0;
diff --git a/libswscale/swscale.c b/libswscale/swscale.c
index 8436f056d4..e163909631 100644
--- a/libswscale/swscale.c
+++ b/libswscale/swscale.c
@@ -766,22 +766,26 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
     int dstStride2[4];
     int srcSliceY_internal = srcSliceY;
 
+#if !defined(__EMSCRIPTEN__)
     if (!srcStride || !dstStride || !dst || !srcSlice) {
         av_log(c, AV_LOG_ERROR, "One of the input parameters to sws_scale() is NULL, please check the calling code\n");
         return 0;
     }
+#endif
 
     for (i=0; i<4; i++) {
         srcStride2[i] = srcStride[i];
         dstStride2[i] = dstStride[i];
     }
 
+#if !defined(__EMSCRIPTEN__)
     if ((srcSliceY & (macro_height-1)) ||
         ((srcSliceH& (macro_height-1)) && srcSliceY + srcSliceH != c->srcH) ||
         srcSliceY + srcSliceH > c->srcH) {
         av_log(c, AV_LOG_ERROR, "Slice parameters %d, %d are invalid\n", srcSliceY, srcSliceH);
         return AVERROR(EINVAL);
     }
+#endif
 
     if (c->gamma_flag && c->cascaded_context[0]) {
         ret = sws_scale(c->cascaded_context[0],
@@ -826,6 +830,7 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
     if (srcSliceH == 0)
         return 0;
 
+#if !defined(__EMSCRIPTEN__)
     if (!check_image_pointers(srcSlice, c->srcFormat, srcStride)) {
         av_log(c, AV_LOG_ERROR, "bad src image pointers\n");
         return 0;
@@ -839,6 +844,8 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
         av_log(c, AV_LOG_ERROR, "Slices start in the middle!\n");
         return 0;
     }
+#endif
+
     if (c->sliceDir == 0) {
         if (srcSliceY == 0) c->sliceDir = 1; else c->sliceDir = -1;
     }
@@ -888,6 +895,7 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
             v = av_clip_uint8((RV * r + GV * g + BV * b + (257 << (RGB2YUV_SHIFT - 1))) >> RGB2YUV_SHIFT);
             c->pal_yuv[i]= y + (u<<8) + (v<<16) + ((unsigned)a<<24);
 
+#if !defined(__EMSCRIPTEN__)
             switch (c->dstFormat) {
             case AV_PIX_FMT_BGR32:
 #if !HAVE_BIGENDIAN
@@ -912,11 +920,15 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
             case AV_PIX_FMT_BGR24:
 #endif
             default:
+#else
+            {
+#endif
                 c->pal_rgb[i]=  b + (g<<8) + (r<<16) + ((unsigned)a<<24);
             }
         }
     }
 
+#if !defined(__EMSCRIPTEN__)
     if (c->src0Alpha && !c->dst0Alpha && isALPHA(c->dstFormat)) {
         uint8_t *base;
         int x,y;
@@ -933,6 +945,7 @@ int attribute_align_arg sws_scale(struct SwsContext *c,
         }
         src2[0] = base;
     }
+#endif
 
     if (c->srcXYZ && !(c->dstXYZ && c->srcW==c->dstW && c->srcH==c->dstH)) {
         uint8_t *base;
